package hash

import (
	"testing"

	"github.com/Electron-Labs/plonky2-groth16-verifier/goldilocks"
	poseidonBn254 "github.com/Electron-Labs/plonky2-groth16-verifier/poseidon/bn254"
	"github.com/Electron-Labs/plonky2-groth16-verifier/verifier/types"
	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/frontend/cs/r1cs"
	"github.com/consensys/gnark/test"
)

type TestHashNoPad struct {
	Inputs []goldilocks.GoldilocksVariable
	Hash   types.PoseidonBn254HashOut
}

type TestTwoToOne struct {
	Left  types.PoseidonBn254HashOut
	Right types.PoseidonBn254HashOut
	Hash  types.PoseidonBn254HashOut
}

func (circuit *TestHashNoPad) Define(api frontend.API) error {
	poseidonBn254 := &poseidonBn254.PoseidonBn254{}
	hasher := NewPoseidonBn254Hasher(api, poseidonBn254)
	computedHash := hasher.HashNoPad(api, circuit.Inputs)

	api.AssertIsEqual(computedHash.HashOut, circuit.Hash.HashOut)
	return nil
}

func (circuit *TestTwoToOne) Define(api frontend.API) error {
	poseidonBn254 := &poseidonBn254.PoseidonBn254{}
	hasher := NewPoseidonBn254Hasher(api, poseidonBn254)
	computedHash := hasher.TwoToOne(api, circuit.Left, circuit.Right)

	api.AssertIsEqual(computedHash.HashOut, circuit.Hash.HashOut)
	return nil
}

func TestPoseidon254HashNoPad(t *testing.T) {
	assert := test.NewAssert(t)

	var circuit TestHashNoPad

	circuit.Inputs = goldilocks.GetGoldilocksVariableArr([]uint64{12987097349963159569, 8519720078137958023, 12502395793199898663, 13163480486271996737, 2601359304611665310, 13601282488975293041, 9773553971628027046, 15299383659781289576, 12178066977565821860, 14838768266880835355, 10273198213592986101, 11149216025130692304, 1449463113422137075, 3961924183184968917, 2652090029460391324, 4448307069412668407, 6414348715848785040, 4200225364124476850, 16512985419737822652, 16020988038878674244, 4484940669602791493, 8087791266822289232, 167216383651069757, 3619986112681836139, 13890755247599715550, 18089130090147600180, 14104911688512215816, 3170199854819354548, 1228454578063911241, 8800768677968357273, 16117596742067945181, 11591294822461529496, 13056324960777388624, 9635869061589142629, 15527464142753058444, 13008812052939163828, 7218056891131324845, 194041175801402260, 571642463218411303, 3820029588041095575, 9061914426016275426, 15496851539579904967, 7454493050726298749, 3859238387622068038, 8945279025282383367, 13865771064821703072, 4896067461696504979, 5765845834464030096, 5604842904426314523, 10023114215288651280, 4882003316218242102, 8737796487198019746, 9551386924349199714, 3326615995741196321, 8007478161738243067, 5501358838063037169, 3577127080100202311, 15992096502494881611, 4447746003524741385, 893816488509868933, 10946127042804039446, 4090869640635088928, 16820082341274327847, 6231076860103526897, 13487474926130636742, 13833149889251367434, 5094933451136081978, 506100813340195366, 9391455817063334187, 12733252230375965050, 2743898155863424355, 16109688317861092901, 6964163944443342725, 10381544026824886761, 2611839447075273758, 14986081691515318485, 8207503718852487899, 14945357535548372652, 17580272896188208139, 17638096712363869995, 4871503912430491541, 15742731368593120619, 14193205077079543506, 946557235025511139})
	circuit.Hash = types.PoseidonBn254HashOut{HashOut: "2541485809695854931609921186711480233085658399528320855995727505901045388016"}

	r1cs, err := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &circuit)
	if err != nil {
		t.Fatal("failed to compile: ", err)
	}

	t.Log("NbConstraints: ", r1cs.GetNbConstraints())

	var assignment TestHashNoPad
	// assignment.Inputs = []goldilocks.GoldilocksVariable{a, b}
	assignment.Inputs = goldilocks.GetGoldilocksVariableArr([]uint64{12987097349963159569, 8519720078137958023, 12502395793199898663, 13163480486271996737, 2601359304611665310, 13601282488975293041, 9773553971628027046, 15299383659781289576, 12178066977565821860, 14838768266880835355, 10273198213592986101, 11149216025130692304, 1449463113422137075, 3961924183184968917, 2652090029460391324, 4448307069412668407, 6414348715848785040, 4200225364124476850, 16512985419737822652, 16020988038878674244, 4484940669602791493, 8087791266822289232, 167216383651069757, 3619986112681836139, 13890755247599715550, 18089130090147600180, 14104911688512215816, 3170199854819354548, 1228454578063911241, 8800768677968357273, 16117596742067945181, 11591294822461529496, 13056324960777388624, 9635869061589142629, 15527464142753058444, 13008812052939163828, 7218056891131324845, 194041175801402260, 571642463218411303, 3820029588041095575, 9061914426016275426, 15496851539579904967, 7454493050726298749, 3859238387622068038, 8945279025282383367, 13865771064821703072, 4896067461696504979, 5765845834464030096, 5604842904426314523, 10023114215288651280, 4882003316218242102, 8737796487198019746, 9551386924349199714, 3326615995741196321, 8007478161738243067, 5501358838063037169, 3577127080100202311, 15992096502494881611, 4447746003524741385, 893816488509868933, 10946127042804039446, 4090869640635088928, 16820082341274327847, 6231076860103526897, 13487474926130636742, 13833149889251367434, 5094933451136081978, 506100813340195366, 9391455817063334187, 12733252230375965050, 2743898155863424355, 16109688317861092901, 6964163944443342725, 10381544026824886761, 2611839447075273758, 14986081691515318485, 8207503718852487899, 14945357535548372652, 17580272896188208139, 17638096712363869995, 4871503912430491541, 15742731368593120619, 14193205077079543506, 946557235025511139})
	assignment.Hash = types.PoseidonBn254HashOut{HashOut: "2541485809695854931609921186711480233085658399528320855995727505901045388016"}

	witness, err := frontend.NewWitness(&assignment, ecc.BN254.ScalarField())
	if err != nil {
		t.Fatal("Error in witness: ", err)
	}

	err = r1cs.IsSolved(witness)
	if err != nil {
		t.Fatal("failed to solve: ", err)
	}

	assert.CheckCircuit(&circuit, test.WithValidAssignment(&assignment), test.WithCurves(ecc.BN254))
}

func TestPoseidon254TwoToOne(t *testing.T) {
	assert := test.NewAssert(t)

	var circuit TestTwoToOne

	circuit.Left = types.PoseidonBn254HashOut{HashOut: "6281904892014791868705219699957496985005720033780326396876219596728127146758"}
	circuit.Right = types.PoseidonBn254HashOut{HashOut: "4947177603646695235300728304109696766792913382766045508801307633864513106919"}
	circuit.Hash = types.PoseidonBn254HashOut{HashOut: "325766602379896428695352943246037863354300800134188688297414800288559471759"}

	r1cs, err := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &circuit)
	if err != nil {
		t.Fatal("failed to compile: ", err)
	}

	t.Log("NbConstraints: ", r1cs.GetNbConstraints())

	var assignment TestTwoToOne
	assignment.Left = types.PoseidonBn254HashOut{HashOut: "6281904892014791868705219699957496985005720033780326396876219596728127146758"}
	assignment.Right = types.PoseidonBn254HashOut{HashOut: "4947177603646695235300728304109696766792913382766045508801307633864513106919"}
	assignment.Hash = types.PoseidonBn254HashOut{HashOut: "325766602379896428695352943246037863354300800134188688297414800288559471759"}

	witness, err := frontend.NewWitness(&assignment, ecc.BN254.ScalarField())
	if err != nil {
		t.Fatal("Error in witness: ", err)
	}

	err = r1cs.IsSolved(witness)
	if err != nil {
		t.Fatal("failed to solve: ", err)
	}

	assert.CheckCircuit(&circuit, test.WithValidAssignment(&assignment), test.WithCurves(ecc.BN254))
}
